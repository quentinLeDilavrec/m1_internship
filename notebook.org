#+TITLE: Comparing test and production behavior for dynamic languages
#+AUTHOR: Quentin Le Dilavrec
#+LaTeX_CLASS: llncs
#+LaTeX_CLASS_OPTIONS: [runningheads]
#+LANGUAGE: american
#+EMAIL:     (concat "quentin.le-dilavrec" at-sign "ens-rennes.fr")
#+SEQ_TODO: APPT(a) TODO(t) NEXT(n) STARTED(s) WAITING(w) HALF(h) APPT(a) | DONE(d) CANCELLED(c) DEFERRED(f)
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org.css"/>
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{relsize}
# #+LATEX_HEADER: \renewcommand\UrlFont{\color{blue}\rmfamily}
#+LATEX_HEADER: \usepackage[american]{babel}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{mdframed}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \usepackage[a-1b]{pdfx}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage[normalem]{ulem}
#+MACRO: color @@latex:{\color{$1}@@$2@@latex:}@@

* Introduction
Testing a software system is a fundamental process in software development 
and considerable amount of the total development cost is reserved for software testing.

And extensive research {{{color(red,citations)}}} has been done to improve software quality,
through methods revolving around test and verification.
But there is a trade-off between the flexibility granted by a languages
and the cost of its analysis.
In the case of dynamic languages like javascript,
whose success come from the low entry cost and flexibility for developers,
it combine the imperative and functional paradigm and allow to evaluate code at runtime,
all those degree of freedom make it very hard to gather the necessary information
that will allow in depth analysis. 
In this conditions even if tests are particularly adapted as they have access to runtime information,
all the methods revolving around automated tests generation are lagging behind like analyzers
because of the lack of runtime in formations.
To close the gap we can try to harvest information at runtime 
but it come at a cost, first like tests it consume computing power,
second it might change the behavior of the system,
and third due to the vast number of run variations present in complex systems,
the harvested information needs to represent the real usage of the system.
The apparent trade-of here is between the precision of the instruments 
and the impact of those instruments on the studied systems.
On one hand less precise traces representing runtime information will lessen the precision of the analysis,
on the other hand instrumenting complex systems can impact performances and validity
and can't be neglected as it will impede the accuracy of subsequent analysis.
# such as type cast, function overloading, higher order functions, runtime evaluations.
# In this conditions, tools like static analyzers are also less effective,
# making tests even more important.

We aim at useful analysis of widely used software,
that allow us to give useful feedback on those software code quality, 
through mainly the coverage by tests of behavior observable in field.

The results obtained can help developers understanding the behavior of a piece of software,
but can also be feed to more classical automated test generation tools.
# Making software based on dynamic languages/interpreters more reliable and competitive 
# in domain previously favoring static languages.
* Context
* Logging javascript calls in browser and nodejs
 
 high-level information on the behaviour of commonly used software,
we looked at web applications running in browsers and also extensively tested with, for example, unit tests.
Whether it is inside a browser or during compilation, the approach to gather data at runtime is done,
by first adding a new step in the compilation/loading pipeline, 
this we allow to proceed with the modification of the program, 
that will intercept runtime data on the instrumented program.
At runtime it is also necessary to expose a collection point to the instrumenting instruction
that will handle the collection of data. 
# interception in a pipeline -> intrumentation of content -> getting data from things added during instrumentation
In the next subsections we will explain how we instrument actual javascript code to log function calls
** logging
In cite:wang17_behav_execut_compar Wang and al. log the calls at method level because prior work has argued that method call sequences
represent the best cost-benefit tradeoff for reproducing field failures cite:Jin_2012.
However in javascript there are many ways to create reusable pieces of code,
- named function
- anonymous function
- object method
- lambda expression
- Function/eval
- class methods

The official Abstract Syntaxe Definition of /TreeJS/ regroup them as a type union under the name Function.
As a common denominator they all be called using the standard call syntax
Moreover they can also be used and exposed in different ways,
- as an attribute of an object
- returned by a function
- passed as a parameter
- in a variable

This variability allow a great flexibility for the developer
but makes analysis more complicated.
Thus we decided to instrument all those kinds of functions by only adding an instruction at the start of the declaration body,
this instruction append to the trace a new element made of the identifier of the function and parameters
We tried to make it the least intrusive possible by only adding this one line and serializing the parameters,
in the case of lambda expression without a block (only allowing an expression but no instructions)
we choose to
- transform it into a block, doesn't change call stack and wrap the expression in a return instruction
- use the coma operator, not very known
- wrap it with a call, problem with scope
** dynamic instrumentation
In a browser, we found 2 way to instrument javascript that allowed us to change the text of the script.
One can be implemented using an extension which allow us to modify the the loading of the page at parsing,
the other make use of the /DevTools/ API that allow us to intercept http requests and responses.
The first method is most accessible one as it only need to install a new browser extension,
the second one is more instrusive and need to be launch as a new process,
but it allow us to access more low level API and make use of the cache, loading parallelization
and offload the instrumentation to a background process.
#+NAME: dynamic instrumentation shema
#+ATTR_LaTeX: :float t :options frame=single,framesep=20pt,fontsize=\tiny
#+LABEL: shema:instru
#+CAPTION: Schema representing the different approaches to dynamic js instrumentation in browser
#+BEGIN_SRC bash

--------<script src="xxxxx.js"></script>----<script src="xxxx.com/xxxx.js"></script>----<script>xxxxxxxxxx</script>--->
         \                            /      \                                    /            \         /
 DOM      \                         (*)       \                                 (*)             \      (*) 
          (1)                       /         (4)                               /                \-(6)-/
            \                      /            \                              /
-------------v--------------------^--------------\----------------------------/----
              \                  /                \                          /
 NETWORK      (2)              (3)                (2)                      (3)
                \              /                    \                      /
-----------------\------------/----------------------\--------------------/---------------------------
                  \          /                        \                  /
                                                       \----------(5)---/
                                                          \    /

#+END_SRC

#+RESULTS: shema:instru

1) interception at DOM parsing, get the script tag as parameter, request script source, then instrument text of tag and populate innerhtml of tag
2) interception of outgoing query, to redirect to other url or directly respond to query
3) interception of response packet, intrument text in packet body then forward
4) interception at DOM parsing, get the script tag, +get script source code, then instrument text of tag+, CORS domain policy forbid programmatic requests to remote domains, so need to modify url to go through intermediary server
5) use an intermediary server to instrument script, need to change the original url
6) interception at DOM parsing, get the script tag, then instrument inner text of tag
*) parsing and evaluation of javascript tab by web browser
*** (Intercepting) DOM parser events
Our most accessible method to instrument javascript code rely on
observing parse events [fn::https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver], 
it allow us to modify scripts added on the page during DOM construction
This _observer_ can be directly included in the original page as the first script tag,
on dynamically added to pages with a web browser extension or using the DevTools API
But in some cases this approach can change the behavior of script tags.
actually local scripts need to be transformed into to inline scripts.
The main problem of this method is the impact on performance
because it can't make use of the web browser cache,
thus it need to instrument the page at every load.
{{{color(red,transformations examples? pseudo code?)}}}
*** (Intercepting) http requests
The second method is more efficient as it make use of the cache
but it can only be implemented though the Fetch domain of Devtools API.
{{{color(red,talk about pupeteer? here? or in the dynamic instrumentation section?)}}}
to intercept and modify incoming responses to scripts requested.
js parsing to instrument code is done in the puppeteer (nodejs) process,
relieving the web browser of some stress and isolating the instrumentation process from the rest of the application. 
Don't work on inline scripts at this point (maybe intercepting html request and parsing the DOM)
More than just an extension, but Docker container available (in this case it needs X).
** compile time instrumentation
All of the big web applications uses some kind of compilation in there pipeline.
It allow for greater development flexibility and automating retro-compatibility.
We used created an AST transformation that integrate to most compilation pipelines,
it conform to the official Abstract Syntaxe Definition of /TreeJS/ and is implemented through the /babeljs/ compiler.
{{{color(red, talk about problem of instrumentation passes?)}}}
* Making use of traces
One of our main concern was to adapt state of the art software analysis methods
to the development of web applications.
In this condition some requirements are necessary:
- low latency responses
- no false negatives
- incremental responses from most important to less important
- no grand8 reports (no appearing and disappearing of error),
  only increase importance level, never decrease without user implication

Behavior of the system
Extensive research [...] has been done to represent the behavior of software systems.  



** Processing of traces {{{color(red,logs or traces?)}}}
# One of the big challenges is to process the logs fast.
** Representing mined information
Another challenge is to relate the information mined from logs in a meaning and useful way.

* Application to Wordpress
Why Wordpress?
** Experimental procedure
*** Production
Multiple people with their personal computer do things with an instance of /Wordpress/ shared over local network
*** Tests
Run on a intel I7, gtx960M, 8Go RAM laptop.
** Results
*** distribution of calls on dataset
#+BEGIN_EXAMPLE
production/test calls sorted by number of occurences of production.
y axis show # of calls
x axis show calls, only some interesting calls should be visible.
#+END_EXAMPLE

#+NAME: wordpress ditrib
#+CAPTION: Distribution of number of calls per JS functions for production (grey) for tests (red) in traces of Wordpress 
#+ATTR_ORG: :width 600
#+ATTR_LATEX: :width 5in
[[file:plots/distrib.png]]
*** distribution of calls on dataset per gutenberg package
#+BEGIN_EXAMPLE
production/test calls sorted by number of occurences of production.
y axis show # of calls, (log2 scale)
x axis show calls, only some interesting calls should be visible.
data faceted by package
#+END_EXAMPLE

#+NAME: wordpress multi-ditrib
#+CAPTION: Distribution of number of calls per JS functions for production (grey) for tests (red) in traces of Wordpress split by packages 
#+ATTR_ORG: :width 600
[[file:plots/multidistrib3.png]]

#+NAME: wordpress multi-ditrib
#+CAPTION: Distribution of number of calls per JS functions for production (grey) for tests (red) in traces of Wordpress split by packages with values truncated to 1000 calls, to make it bigger.
#+ATTR_ORG: :width 600
[[file:plots/multidistrib.png]]
*** Venn diagram with symbols of functions
#+BEGIN_SRC ditaa :file images/venn_prod_test_calls_symbols.png

  +------------------------------------------------------+
  | instrumented                                         |
  | symbols              +-------------------------+     |
  |                      |                         |     |
  |         +------------+----------+              |     |
  |         |            |          |              |     |
  |         |            |  prod    |    prod      |     |
  |         |            |   n      |              |     |
  |         |    test    |  test    |              |     |
  |         |            |          |              |     |
  |         |            +----------+--------------+     |
  |         |                       |                    |
  |         +-----------------------+                    |
  |                                                      |
  +------------------------------------------------------+

#+END_SRC
*** Venn diagram with function's symbols and parameters
#+BEGIN_SRC ditaa :file images/venn_prod_test_call_symbols_and_parameters.png

                         +-------------------------+     
                         |                         |     
            +------------+----------+              |     
            |            |          |              |     
            |            |  prod    |    prod      |     
            |            |   n      |              |     
            |    test    |  test    |              |     
            |            |          |              |     
            |            +----------+--------------+     
            |                       |                    
            +-----------------------+                    

#+END_SRC
*** Precise analysis of methods/functions usage context from field compared to tests 
#+NAME: wordpress createNamespace context
#+CAPTION: createNamespace usage context from field compared to tests, la largeur d'un noeud est proportionnnel à son nombre d'appels en production
#+ATTR_ORG: :width 600
[[file:images/flowgraph.png]]

#+NAME: wordpress createNamespace context
#+CAPTION: callback function wrapping a retruned selector in createNamespace, usage context from field compared to tests, la couleur des noeuds reprentente le rapport entre le nombre d'utilisations en production par rapport aux tests
#+ATTR_ORG: :width 600
[[file:images/flowgraph1.png]]

* Conclusion
The results obtained can help developers understanding the behavior of a piece of software,
but can also be feed to more classical automated test generation tools.
* References                                  :ignore:
bibliographystyle:plain
bibliography:references.bib
** links                                                  :noexport:
# splncs splncs03 plain
- [[https://doi.org/10.1016/j.infsof.2019.05.008][On the Use of Usage Patterns from Telemetry Data for Test Case Prioritization]]
- [[https://people.cs.umass.edu/~brun/pubs/pubs/Wang17icst.pdf][Behavioral Execution Comparison: Are Tests Representative of Field Behavior?]]
- [[https://github.com/INRIA/intertrace]]
- https://people.inf.ethz.ch/suz/publications/natural.pdf https://github.com/labri-progress/naturalness-js
- [[https://arxiv.org/pdf/1906.01463.pdf]]
- [[http://ceur-ws.org/Vol-971/paper21.pdf]]
- http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=877A01775995830BB127116FB11BAB49?doi=10.1.1.323.3411&rep=rep1&type=pdf
- [[https://link.springer.com/content/pdf/10.1007%2Fs10270-019-00737-w.pdf]]
- [[https://cs.uwaterloo.ca/~m2nagapp/courses/CS846/1171/papers/hindle_icse12.pdf][Lossless compaction of model execution traces]]
- [[https://livablesoftware.com/conflictjs-javascript-libraries-conflicts/]]

# # eval:    (setq org-latex-pdf-process '("pdflatex -bibtex -shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex -bibtex -shell-escape -interaction nonstopmode -output-directory %o %f" "pdflatex -bibtex -shell-escape -interaction nonstopmode -output-directory %o %f"))
* Journal                                                          :noexport:
** [2019-05-15 Wed]
*** DONE use Iroh with Mutation Observer to wrap scripts
** [2019-05-16 Thu]
*** DONE adapt [[file:IrohMutationObserverLogger]] to use devTools
** [2019-05-21 Tue]
*** DONE Logging
  Some ways to intrument javascript programs
**** https://stackoverflow.com/questions/11853256/how-to-get-javascript-function-calls-trace-at-runtime
**** https://stackoverflow.com/questions/7439570/how-do-you-log-all-events-fired-by-an-element-in-jquery
**** https://stackoverflow.com/questions/5033836/adding-console-log-to-every-function-automatically

**** Wrapping

***** https://www.npmjs.com/package/call-log
***** https://stackoverflow.com/a/5034657/9854053
  #+BEGIN_SRC js
  function augment(withFn) {
      var name, fn;
      for (name in window) {
          fn = window[name];
          if (typeof fn === 'function') {
              window[name] = (function(name, fn) {
                  var args = arguments;
                  return function() {
                      withFn.apply(this, args);
                      return fn.apply(this, arguments);

                  }
              })(name, fn);
          }
      }
  }

  augment(function(name, fn) {
      console.log("calling " + name);
  });
  #+END_SRC
***** https://stackoverflow.com/a/11854146/9854053
  #+BEGIN_SRC js
  //**************************Set up your functionLogger*****************//
  var functionLogger = {};

  functionLogger.log = true;//Set this to false to disable logging

  /**
   * Gets a function that when called will log information about itself if logging is turned on.
   *
   * @param func The function to add logging to.
   * @param name The name of the function.
   *
   * @return A function that will perform logging and then call the function.
   */
  functionLogger.getLoggableFunction = function(func, name) {
      return function() {
          if (functionLogger.log) {
              var logText = name + '(';

              for (var i = 0; i < arguments.length; i++) {
                  if (i > 0) {
                      logText += ', ';
                  }
                  logText += arguments[i];
              }
              logText += ');';

              console.log(logText);
          }

          func.apply(this, arguments);
      }
  };

  /**
   * After this is called, all direct children of the provided namespace object that are
   * functions will log their name as well as the values of the parameters passed in.
   *
   * @param namespaceObject The object whose child functions you'd like to add logging to.
   */
  functionLogger.addLoggingToNamespace = function(namespaceObject){
      for(var name in namespaceObject){
          var potentialFunction = namespaceObject[name];

          if(Object.prototype.toString.call(potentialFunction) === '[object Function]'){
              namespaceObject[name] = functionLogger.getLoggableFunction(potentialFunction, name);
          }
      }
  };


  //**************************Set up your namespace functions*****************//
  var namespaceObject = {};

  namespaceObject.test1 = function(a, b, c, d, e) {
      namespaceObject.test2(a + b, c + d + e);
  };

  namespaceObject.test2 = function(ab, cde) {

  };





  //**************************Add logging to your namespace functions*****************//
  functionLogger.addLoggingToNamespace(namespaceObject);






  //**************************Test it out*****************//
  namespaceObject.test1("alli", "gator", 3, 4, 5);
  #+END_SRC
***** https://stackoverflow.com/questions/5226550/can-i-override-the-javascript-function-object-to-log-all-function-calls/12425499#12425499
***** Proxy https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
      - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/apply
****** On function
  #+BEGIN_SRC js
  function sum(a, b) {
    return a + b;
  }
  const accu = []
  const handler = {
    apply: function(target, thisArg, argumentsList) {
      console.log(`Calculate sum: ${argumentsList}`);

      // expected output: "Calculate sum: 1,2"

      accu.push({
        name: target.name,
        args: argumentsList
                });

      return target(argumentsList[0], argumentsList[1]) * 10;
    }
  };

  var proxy1 = new Proxy(sum, handler);

  console.log(sum(1, 2));
  // expected output: 3
  console.log(proxy1(1, 2));
  // expected output: 30

  console.log(proxy1.call(this,1, 2));

  console.log(proxy1.apply(null,[1, 2]));

  console.log(accu);
  #+END_SRC

****** On class
  #+BEGIN_SRC js
  function Hero(name, level) {
      this.name = name;
      this.level = level;
  }

  // Adding a method to the constructor
  Hero.prototype.greet = function() {
      return `${this.name} says hello.`;
  }

  // Creating a new constructor from the parent
  function Mage(name, level, spell) {
      // Chain constructor with call
      Hero.call(this, name, level);

      this.spell = spell;
  }

  Mage.prototype = new Hero;

  // Initializing a class
  class HeroC {
      constructor(name, level) {
          this.name = name;
          this.level = level;
      }

      // Adding a method to the constructor
      greet() {
          return `${this.name} says hello.`;
      }
  }

  // Creating a new class from the parent
  class MageC extends HeroC {
      constructor(name, level, spell) {
          // Chain constructor with super
          super(name, level);

          // Add a new property
          this.spell = spell;
      }
  }

  const loggerC = className => {
    return new Proxy(new className(), {
      get: function(target, name, receiver) {
        if (!target.hasOwnProperty(name)) {
          if (typeof target[name] === "function") {
            console.log(
              "Calling Method : ",
              name,
              "|| on : ",
              target.constructor.name
            );
          }
          return new Proxy(target[name], this);
        }
        return Reflect.get(target, name, receiver);
      }
    });
  };

  const logger = obj => {
    return new Proxy(obj, {
      get: function(target, name, receiver) {
        if (!target.hasOwnProperty(name)) {
          if (typeof target[name] === "function") {
            console.log(
              "Calling Method : ",
              name,
              "|| on : ",
              target.constructor.name
            );
          }
          return new Proxy(target[name], this);
        }
        return Reflect.get(target, name, receiver);
      }
    });
  };

  //const instance = logger(Mage)
  const instanceC = loggerC(MageC)

  console.log("a");

  instanceC.greet()
  #+END_SRC

***** setPrototypeOf https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf
       - less spread, less clean but change already existing class
       not sure here

***** Modify program text (using an AST https://github.com/benjamn/recast)
***** use api of the webbrowser
      - seem to be unstable on most browsers
      - faster?
      - cleaner
      - not really portable
      - complicated
*** DONE Temporal Invarients Mining
    CLOSED: [2019-05-30 Sun 21:13] basic impl don't scale

  - [X] get methods call from log
  - [X] give it to a model inference algorith like kTails (impl. in InvariMint)

*** DEFERRED Using maps of mignifiers to compress logs
    CLOSED: [2019-06-30 Sun 21:12] and get function position in source
  //https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/
  particulièrement pour le cas des remotes sources.

*** DEFERRED Recursive Mutation Observers for iframes?
    CLOSED: [2019-06-30 Sun 21:12]
  detect it, then attach a MO to it.

*** DEFERRED Serialize arguments in a mindfull way
    CLOSED: [2019-06-30 Sun 21:12]
  control deph and type

*** DONE intercept WordPress tests
    CLOSED: [2019-06-04 Tue 16:37]
  modifying imports?
**** HALF use babel for plugins browserification
*** DEFERRED hash of inline scripts
    CLOSED: [2019-06-30 Sun 21:12]
allow to compare duplicated scripts
but don't work without maps or between compilations.

*** CANCELLED 2 passes for prefetch
    CLOSED: [2019-05-21 Tue 15:52]
  switched Fetch API of v8 works like normal requests

*** CANCELLED reduce Iroh modifications
    CLOSED: [2019-05-21 Tue 15:51]
  switched to babeljs
** [2019-05-22 Wed]
*** Advancements made on first week
- I spoke with Nicolas H. and Javier C. about what I had done to prepare the internship :: Explaining the context, so that they can give me pointers to useful resources
- Javier convinced me to use v8 devTools to do the wrapping
  - Sadly traces created by v8 are done by sampling and don't get all calls (confirming some of my observations during preparation), Profiling don't get parameters
  - But the Debugger and Runtime interfaces are able to get and set scripts content :: So I adapted the [[file:IrohMutationObserverLogger]]
    - The content of inline scripts can't be changed using v8 so the new method only apply to local and remote script files
    - It work well without changing script loading and evaluation behavior
    - But the wrapping have a linear complexity, leading to big loading time is some cases like when creating a new WP post on the web interface
  - Ater some more research, I found an experimental interface of devTools called Fetch which intercept HTTP requests :: Leading to the same wrapping but only at the cost of a few ms (it now uses cache and wrapping are paralyzed by default)
- I am now on making the interception in the tests of WordPress
  - Most tests are in plugins (for example the new blocs plugin introduced by gutemberg)
- I am also thinking about better ways of identifying functions, making use of calls parameters and wrapping as much as possible during compilation

** [2019-05-27 Mon]
*** Number of calls with puppeteer getting and  writting on disk 1 per call
fail because resetting  this.log and not log
#+BEGIN_EXAMPLE
cat * | wc
      0       1 139670000
#+END_EXAMPLE
more like that with 10 one per call (to see available bandwith)
#+BEGIN_EXAMPLE
cat * | wc
      0       1 65380000
#+END_EXAMPLE

*** HALF read [[https://doi.org/10.1016/j.infsof.2019.05.008][On the Use of Usage Patterns from Telemetry Data for Test Case Prioritization]]
- Telemetry / interception of requests
- Fingerpints
*** HALF look at [[https://github.com/INRIA/intertrace]]
- tracing API, give methods to trace events
- Django
** [2019-05-28 Tue]
*** Summary
We summaries the advancement made until now (also speaking about possible improvements)
Starting with possible uses of what we are able to produce, then explaining how we produced it.
**** Uses of the data produced
- Calls made during tests    + Functions declared in code   => Static test coverage
- Calls made during tests    + Calls made during production => Dynamic/Behavioral Test coverage
- Functions declared in code + Calls made during production => Code usage
**** Tools developped until now for this internship
The following tools require the analysis of code AST. (respecting the ESTree specification)
Instrumentation is mostly done at compile time using Babeljs,
then during runtime logs are pushed to a global variable similar to a list.
***** Functions declared in code
Dynamic lookup in source using ESlint, it underline problems, and propose/apply fix.
***** Calls made during tests
Each test is run in an isolated environment,
before each test the global variable storing logs is instantiated,
after each test logs are written on disk.
***** Calls made during production
The browser is launched using puppeteer
each launched page instantiate the global variable storing logs.
Here logs are flushed every n intercepted calls to lower the header part.

** [2019-06-01 Sat]
*** DONE read [[https://people.cs.umass.edu/~brun/pubs/pubs/Wang17icst.pdf][Behavioral Execution Comparison: Are Tests Representative of Field Behavior?]] again, to recenter the project and construction of the arguments that will be soon developed
    CLOSED: [2019-06-09 Sun 16:38]
Confronting my experience of the last weeks I hope to see this paper in a new light.
**** vocabulary
- used in production -> *used in the field*
- software testing
- field data
- model inference
- Behavioral models
- behavior
**** context
Software testing is the most widely used approach
for assessing and improving software quality
**** industrial aim
Provide insight for developers and suggest a
better method for measuring test suite quality
**** claims
Tests may not be representative of how the software is used in the field.
To prove it, they apply the presented method on 1 end-user and 3 client software.
Automatically-generated tests created by a tool
targeting high code coverage (static analysis) only marginally improves the tests’
behavioral representativeness.
They hypothesize that the finer-grained model is better suited for identifying behavioral
differences and is thus more useful in assessing test suite quality than coverage and mutation.
**** achievements
Present a model based on temporal invariant (dynamic analysis)(kTails-based invariants[6][10]).
But also compare to coverage based models (industry usage [1][22][27][28][30])
and a mutation-based model (industry usage[33]).
**** intro
- There is not a broad understanding of the extent to which test cases may fall short in representing real-world executions,
- The ways in which tests and realworld executions differ :: help to create novel metrics
- What can be done to bridge this gap in an effective and efficient way :: measure improvements of test suites

**** Behavioral models
- a set of source code statements covered by executions (test/field)
- a set of methods covered by executions
- a set of mutants killed by executions
- a set of temporal invariants over executed methods that hold over the executions.

*** HALF look at mutation based models for tests
*** STARTED read https://people.inf.ethz.ch/suz/publications/natural.pdf and look at https://github.com/labri-progress/naturalness-js
*** DONE implement SQL requests doing the same things as grep and uniq -c
    CLOSED: [2019-06-04 Tue 14:41]
#+BEGIN_SRC sql
SELECT CONCAT(path,':',sl,'',sc,':',el,':',ec), params, COUNT(*), SIGN(session) FROM CALLS
WHERE path = ? AND sl = ? AND sc = ? AND el = ? AND ec = ?
GROUP BY path, sl, sc, el, ec, params, SIGN(session)
#+END_SRC
*** DEFERRED implement SQL requests doing behavioral inferences
    CLOSED: [2019-06-19 Wed 14:42] maybe extending from my postgres recursive function
#+BEGIN_SRC sql
SELECT * FROM
  calls,
  (SELECT root, session, next_line FROM calls
  WHERE calls.path = currpath
  AND calls.sl = currsl
  AND calls.sc = currsc
  AND calls.el = currel
  AND calls.ec = currec) AS init
WHERE init.root = calls.root
AND init.session = calls.session
AND init.next_line = calls.line
#+END_SRC
*** HALF read https://people.cs.umass.edu/~brun/pubs/pubs/Beschastnikh15tse.pdf
*** DONE look at invarimint hadoop 2017 http://isisell.com/freeupload/741894_5942935424157615043.pdf
    CLOSED: [2019-06-09 Sun 16:39]
*** TODO show https://app.logrocket.com/nvhohr/test/sessions
** [2019-06-03 Mon]
*** HALF look at https://docs.timescale.com/v1.3/introduction
- superset of SQL
- didn't see INFILE insertions
- really adapted to logs but only one order improvements?
** [2019-06-05 Wed]
*** TODO read [[https://arxiv.org/pdf/1906.01463.pdf]]
*** TODO look at [[https://github.com/github/semantic]]
*** CANCELLED prototype idea about splitting logs by gutenberg modules
    CLOSED: [2019-06-19 Wed 14:38] Done with the postgres function searching recursivly from some symbols
Something like =extract logs l where dist(l,c)<d with c a call to a function from current package=.
Then it can be used to color/represent logs,
or otherwise

*** DONE meeting with Benoit B. and Javier C.
**** STARTED plot #n-gram over value of n
Need data, hopefully make first batch next +friday+ monday.
***** DONE count ngrams
      CLOSED: [2019-06-10 Mon 16:51]
****** 1-grams
=sort | uniq -c=
****** simulating n-grams calculation using 1-gram technic and transforming each line into it and x previous lines
- keep x lines in a circular array
- read lines with stream
- output to 1-gram algo as a stream current and x prev lines
****** results
uniq ngrams count grow linearly from ~20k up to 70k for 10-grams
#+BEGIN_SRC

#+END_SRC
** [2019-06-07 Fri]
*** STARTED read [[http://ceur-ws.org/Vol-971/paper21.pdf]]
*** CANCELLED Produce logs
    CLOSED: [2019-06-07 Fri 16:10] Bug, no logs produced, investigating in following days.
- with Benoit and Javier on their computer, respectively Ubuntu and OSX.
- for Docker using GUI, with OSX it needs XQuartz, that is difficult to install
- on first docker usage need to start the deamon, =sudo systemctl start docker=
- on first use of X11 combined with docker run =xhost local:root= allowing local clients to communicate with X11 server
- [X] need to automatically create temporary directory for logs if it doesn't exist
** [2019-06-08 Sat]
*** DONE make experimental setup ready
Now working with public IP.
Last Friday problems were coming from a static config (localhost) of Gutenberg setup scripts.

*** TODO reduce number of nodes intercepted
- using some sort of plugin structure? (at least make it easier)
**** Gutenberg
- filter arrow function smaller than something and inside reduce
- get comment to enable or disable instrumenting
*** WAITING format hints better
- print firsts most used cases that are not tested
- if hint size less than something print firsts most used cases that are not tested enough
- normalize results by something
*** DONE make some logs myself
    CLOSED: [2019-06-10 Mon 13:53]
*** DONE vscode plugin is working well
*** TODO improve functions identification using a dict to check for names collisions at compile time.
functions instrumented later (runtime (in eval?)) can be named by other means
*** DONE show line 57537 to Javier of file logs/2
    CLOSED: [2019-06-10 Mon 09:31]

** [2019-06-12 Wed]
*** DONE switch to postgress for LTREE and custom functions
    CLOSED: [2019-06-16 Sun 14:47]
http://patshaughnessy.net/2017/12/13/saving-a-tree-in-postgres-using-ltree
#+NAME: Creation table
#+BEGIN_SRC sql
CREATE EXTENSION ltree;
CREATE TABLE calls (
  origin char(10) NOT NULL,
  path ltree NOT NULL,
  sl integer NOT NULL,
  sc integer NOT NULL,
  el integer NOT NULL,
  ec integer NOT NULL,
  session integer NOT NULL,
  line integer NOT NULL,
  params json DEFAULT NULL,
  PRIMARY KEY (origin,session,line)
);
create index ON calls using gist(path);
create index ON calls(path,sl,sc,el,ec);
#+END_SRC

#+NAME: Testing calls table
#+BEGIN_SRC sql
CREATE OR REPLACE FUNCTION public.formatPath(s char)
 RETURNS ltree AS $BODY$
BEGIN
    return text2ltree(REPLACE(REPLACE(REPLACE(REPLACE(s,'ç','çç'),'-','ç1'),'.','ç0'),'/','.'));
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;
CREATE OR REPLACE FUNCTION public.formatPath(l ltree)
 RETURNS char AS $BODY$
BEGIN
    return REPLACE(REPLACE(REPLACE(REPLACE(ltree2text(l),'.','/'),'ç0','.'),'ç1','-'),'çç','ç');
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;
SELECT formatPath('packages/edit-post/src/store/test/selectors.js');
DELETE FROM calls;
INSERT INTO CALLS (origin, path, sl, sc, el, ec, session, line, params) VALUES
('test1', formatPath('packages/edit-post/src/store/test/selectors.js'), 205, 40, 211, 3, -5375, 1, NULL),
('test1', formatPath('packages/edit-post/src/store/selectors.js'), 111, 7, 113, 1, -5375, 2, '["[Object]", "post-status"]'),
('test1', formatPath('packages/scripts/config/global-setup.js'), 70, 11, 76, 1, -5375, 3, NULL),
('test1', 'packages.scripts.config.globalç1setupç0ts', 70, 11, 76, 1, -5377, 3, NULL),
('test1', formatPath('packages/blocks/src/api/raw-handling/test/figure-content-reducer.js'), 35, 36, 40, 2, -5374, 1, NULL);
SELECT formatPath(path) FROM calls;
#+END_SRC

#+NAME: Initial requests
#+BEGIN_SRC sql
CREATE OR REPLACE FUNCTION public.myreq(initPath text)
 RETURNS TABLE(init text, p text, t bigint) AS $BODY$
DECLARE
    chunk int[];
    n int;
BEGIN
    n:=1;
    CREATE TEMP TABLE accTable (n int, hash text, session int, ori int, moves text) on commit drop;
    INSERT INTO accTable (hash, n, session, ori, moves)
    SELECT n, MD5(formatPath(path)),
           calls.session, line,''
    FROM CALLS
    WHERE path @> formatPath(initPath);

    CREATE TEMP TABLE groupTable (n int, hash text, pocc bigint, tocc bigint) on commit drop;
    INSERT INTO groupTable (n, hash, pocc, tocc)
    SELECT (accTable.n, accTable.hash,
           COUNT(SIGN(session)>0),
           COUNT(SIGN(session)<0)
    FROM accTable
    GROUP BY accTable.n, accTable.hash;

    INSERT INTO groupTable (n, hash, p, t)
    SELECT (n, hash,
           CASE WHEN SIGN(session)>0 THEN 'prod' ELSE 'test' END,
           COUNT(*)
    FROM accTable
    GROUP BY n, hash, SIGN(session);

    n:=n+1
    INSERT INTO accTable (hash, n, session, ori, moves)
    SELECT n, MD5(formatPath(path)+hash),
    accTable.session, accTable.ori, CONCAT(moves,'p')
    FROM CALLS, accTable
    WHERE accTable.session = calls.session
    AND ori-1 = line

    INSERT INTO accTable (n, hash, session, ori, moves)
    SELECT n, MD5(hash+formatPath(path)),
    accTable.session, accTable.ori, CONCAT(moves,'n')
    FROM CALLS, accTable
    WHERE accTable.session = calls.session
    AND ori+1 = line

    LOOP
       n:=n+1
       INSERT INTO accTable (hash, n, session, ori, moves)
       SELECT n, hash+formatPath(path),
       accTable.session, accTable.ori , CONCAT(moves,'n')
       FROM CALLS, accTable
       WHERE
       (n%2 = 0 AND )
       ;


       WHEN ????
    END

    RETURN QUERY SELECT * FROM groupTable;
END;
$BODY$ LANGUAGE plpgsql;
SELECT * FROM myreq('packages/edit-post/src/store/selectors.js');
#+END_SRC
#+NAME: v2
#+BEGIN_SRC sql
DROP FUNCTION public.myreq;
CREATE OR REPLACE FUNCTION public.myreq(initPath text)
 RETURNS TABLE(n int, hash text, pocc bigint, tocc bigint) AS $BODY$
#variable_conflict use_variable
DECLARE
    chunk int[];
    n int;
BEGIN
    n:=1;
    CREATE TEMP TABLE accTable (n int NOT NULL, hash text, session int, ori int, moves text) on commit drop;
    INSERT INTO accTable (n, hash, session, ori, moves)
    SELECT n, MD5(formatPath(path)),
           calls.session, line,''
    FROM CALLS
    WHERE path @> formatPath(initPath);

    CREATE TEMP TABLE groupTable (n int, hash text, pocc bigint, tocc bigint) on commit drop;
    INSERT INTO groupTable (n, hash, pocc, tocc)
    SELECT a.n, a.hash,
           SUM((SIGN(a.session)>0)::int),
           SUM((SIGN(a.session)<0)::int)
    FROM accTable a
    GROUP BY a.n, a.hash;

    n:= n + 1;
    -- move to previous line, n=2
    INSERT INTO accTable (n, hash, session, ori, moves)
    SELECT n, MD5(CONCAT(formatPath(c.path),a.hash)),
    a.session, a.ori, CONCAT(a.moves,'p')
    FROM calls c, accTable a
    WHERE a.session = c.session
    AND a.ori-1 = c.line
    AND initPath != formatPath(c.path);

    -- move to next line, n=2
    INSERT INTO accTable (n, hash, session, ori, moves)
    SELECT n, MD5(CONCAT(a.hash,formatPath(c.path))),
    a.session, a.ori, CONCAT(a.moves,'n')
    FROM calls c, accTable a
    WHERE a.session = c.session
    AND a.ori+1 = c.line;

    LOOP

      INSERT INTO groupTable (n, hash, pocc, tocc)
      SELECT a.n, a.hash,
            SUM((SIGN(a.session)>0)::int),
            SUM((SIGN(a.session)<0)::int)
      FROM accTable a
      WHERE n = a.n
      GROUP BY a.n, a.hash;

      EXIT WHEN n >= 3;


      n:= n + 1;
      -- move to previous line, n=2
      INSERT INTO accTable (n, hash, session, ori, moves)
      SELECT n, MD5(CONCAT(formatPath(c.path),a.hash)),
      a.session, a.ori, CONCAT(a.moves,'p')
      FROM calls c, accTable a
      WHERE n-1 = a.n
      AND a.session = c.session
      AND a.ori-1 = c.line
      AND (n%2=0 OR RIGHT(a.moves, 1)='p')
      AND initPath != formatPath(c.path);

      -- move to next line, n=2
      INSERT INTO accTable (n, hash, session, ori, moves)
      SELECT n, MD5(CONCAT(a.hash,formatPath(c.path))),
      a.session, a.ori, CONCAT(a.moves,'n')
      FROM calls c, accTable a
      WHERE n-1 = a.n
      AND a.session = c.session
      AND a.ori+1 = c.line
      AND (RIGHT(a.moves, 1)='n' OR n%2=1);

    END LOOP;

    RETURN QUERY SELECT g.n, a.session, a.ori-(CHAR_LENGTH(a.moves) - CHAR_LENGTH(REPLACE(a.moves, 'p', ''))), g.pocc, g.tocc
    FROM   groupTable g
    CROSS  JOIN LATERAL (
      SELECT a.session, a.ori, a.moves
      FROM   accTable a
      WHERE  g.n = a.n AND g.hash = a.hash         -- lateral reference
      LIMIT  1
      ) a;

END;
$BODY$ LANGUAGE plpgsql;
SELECT * FROM myreq('packages/hooks/src/createCurrentHook.js');
#+END_SRC
#+NAME:v3
#+BEGIN_SRC sql
CREATE OR REPLACE FUNCTION public.formatPath(s char)
 RETURNS ltree AS $BODY$
BEGIN
    return text2ltree(REPLACE(REPLACE(REPLACE(REPLACE(s,'ç','çç'),'-','ç1'),'.','ç0'),'/','.'));
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;
CREATE OR REPLACE FUNCTION public.formatPath(l ltree)
 RETURNS char AS $BODY$
BEGIN
    return REPLACE(REPLACE(REPLACE(REPLACE(ltree2text(l),'.','/'),'ç0','.'),'ç1','-'),'çç','ç');
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;
CREATE OR REPLACE FUNCTION public.(l ltree)
 RETURNS char AS $BODY$
BEGIN
    return REPLACE(REPLACE(REPLACE(REPLACE(ltree2text(l),'.','/'),'ç0','.'),'ç1','-'),'çç','ç');
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;
DROP FUNCTION public.myreq;
CREATE OR REPLACE FUNCTION public.myreq(initPath text)
 RETURNS TABLE(n int, session int, left int, pocc bigint, tocc bigint) AS $BODY$
#variable_conflict use_variable
DECLARE
    chunk int[];
    n int;
BEGIN
    n:=1;
    CREATE TEMP TABLE accTable (n int NOT NULL, hash text, session int, ori int, moves text) on commit drop;
    INSERT INTO accTable (n, hash, session, ori, moves)
    SELECT n, MD5(formatPath(path)),
           calls.session, line,''
    FROM CALLS
    WHERE path @> formatPath(initPath);

    CREATE TEMP TABLE groupTable (n int, hash text, pocc bigint, tocc bigint) on commit drop;
    INSERT INTO groupTable (n, hash, pocc, tocc)
    SELECT a.n, a.hash,
           SUM((SIGN(a.session)>0)::int),
           SUM((SIGN(a.session)<0)::int)
    FROM accTable a
    GROUP BY a.n, a.hash;
    
    n:= n + 1;
    -- move to previous line, n=2
    INSERT INTO accTable (n, hash, session, ori, moves)
    SELECT n, MD5(CONCAT(formatPath(c.path),a.hash)),
    a.session, a.ori, CONCAT(a.moves,'p')
    FROM calls c, accTable a
    WHERE a.session = c.session
    AND a.ori-1 = c.line
    AND NOT (formatPath(initPath) @> c.path);
    
    -- move to next line, n=2
    INSERT INTO accTable (n, hash, session, ori, moves)
    SELECT n, MD5(CONCAT(a.hash,formatPath(c.path))),
    a.session, a.ori, CONCAT(a.moves,'n')
    FROM calls c, accTable a
    WHERE n-1 = a.n
    AND a.session = c.session
    AND a.ori+1 = c.line;
    
    LOOP
    
      INSERT INTO groupTable (n, hash, pocc, tocc)
      SELECT a.n, a.hash,
            SUM((SIGN(a.session)>0)::int),
            SUM((SIGN(a.session)<0)::int)
      FROM accTable a
      WHERE n = a.n
      GROUP BY a.n, a.hash;

      EXIT WHEN n >= 4;

      n:= n + 1;
      -- move to previous line, n=2
      INSERT INTO accTable (n, hash, session, ori, moves)
      SELECT n, MD5(CONCAT(formatPath(c.path),a.hash)),
      a.session, a.ori, CONCAT(a.moves,'p')
      FROM calls c, accTable a
      WHERE n-1 = a.n
      AND a.session = c.session
      AND a.ori-1 = c.line
      AND (n%2=0 OR RIGHT(a.moves, 1)='p')
      AND NOT (formatPath(initPath) @> c.path);

      -- move to next line, n=2
      INSERT INTO accTable (n, hash, session, ori, moves)
      SELECT n, MD5(CONCAT(a.hash,formatPath(c.path))),
      a.session, a.ori, CONCAT(a.moves,'n')
      FROM calls c, accTable a
      WHERE n-1 = a.n
      AND a.session = c.session
      AND a.ori+1 = c.line
      AND (n%2=1 OR RIGHT(a.moves, 1)='n');

    END LOOP;

     RETURN QUERY SELECT g.n, a.session, a.ori-(CHAR_LENGTH(a.moves) - CHAR_LENGTH(REPLACE(a.moves, 'p', ''))), g.pocc, g.tocc
     FROM   groupTable g
     CROSS  JOIN LATERAL (
      SELECT a.session, a.ori, a.moves
      FROM   accTable a
      WHERE  g.n = a.n AND g.hash = a.hash         -- lateral reference
      LIMIT  1
      ) a;

END;
$BODY$ LANGUAGE plpgsql;
SELECT * FROM myreq('packages/hooks/src/createCurrentHook.js');
#+END_SRC
#+NAME: v3 with fct position and fixed moves
#+BEGIN_SRC sql
CREATE OR REPLACE FUNCTION public.formatPath(s char)
 RETURNS ltree AS $BODY$
BEGIN
    return text2ltree(REPLACE(REPLACE(REPLACE(REPLACE(s,'ç','çç'),'-','ç1'),'.','ç0'),'/','.'));
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;
CREATE OR REPLACE FUNCTION public.formatPath(l ltree)
 RETURNS char AS $BODY$
BEGIN
    return REPLACE(REPLACE(REPLACE(REPLACE(ltree2text(l),'.','/'),'ç0','.'),'ç1','-'),'çç','ç');
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;

DROP FUNCTION public.myreq;
CREATE OR REPLACE FUNCTION public.myreq(initPath text, sl int, sc int, el int, ec int,max_n int)
 RETURNS TABLE(n int, hash text, session int, left int, pocc bigint, tocc bigint) AS $BODY$
#variable_conflict use_variable
DECLARE
    chunk int[];
    n int;
    origin char(10);
BEGIN
    origin:='gutenberg';
    n:=1;
    CREATE TEMP TABLE accTable (n int NOT NULL, hash text, session int, "left" int, isLastPrev boolean, ori int, 
                                PRIMARY KEY (n, session, "left", hash)) on commit drop;
    CREATE index ON accTable(n, hash);
    
    INSERT INTO accTable (n, hash, session, "left", isLastPrev, ori)
    SELECT n, MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec)),
           c.session, c.line, false, 0
    FROM CALLS c
    WHERE origin = c.origin
    AND path @> formatPath(initPath)
    AND sl = c.sl
    AND sc = c.sc
    AND el = c.el
    AND ec = c.ec;

    CREATE TEMP TABLE groupTable (n int, hash text, pocc bigint, tocc bigint,
                                  PRIMARY KEY (n, hash)) on commit drop;
    INSERT INTO groupTable (n, hash, pocc, tocc)
    SELECT a.n, a.hash,
           SUM((SIGN(a.session)>0)::int),
           SUM((SIGN(a.session)<0)::int)
    FROM accTable a
    GROUP BY a.n, a.hash;
    
    n:= n + 1;
    -- move to previous line, n=2
    INSERT INTO accTable (n, hash, session, "left", isLastPrev, ori)
    SELECT n, MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec,a.hash)),
    a.session, a."left"-1, true, a.ori+1
    FROM accTable a, calls c
    WHERE n-1 = a.n
    AND a.session = c.session
    AND a.left-1 = c.line
    AND origin = c.origin
    AND NOT (
        formatPath(initPath) @> c.path
        AND sl = c.sl
        AND sc = c.sc
        AND el = c.el
        AND ec = c.ec);
    
    -- move to next line, n=2
    INSERT INTO accTable (n, hash, session, "left", isLastPrev, ori)
    SELECT n, MD5(CONCAT(a.hash,formatPath(c.path),c.sl,c.sc,c.el,c.ec)),
    a.session, a.left, false, a.ori
    FROM accTable a, calls c
    WHERE n-1 = a.n
    AND origin = c.origin
    AND a.session = c.session
    AND a.left+(n-1) = c.line;
    
    LOOP
    
      INSERT INTO groupTable (n, hash, pocc, tocc)
      SELECT a.n, a.hash,
            SUM((SIGN(a.session)>0)::int),
            SUM((SIGN(a.session)<0)::int)
      FROM accTable a
      WHERE n = a.n
      GROUP BY a.n, a.hash;

      EXIT WHEN n >= max_n;

      n:= n + 1;
      ANALYZE accTable;
      -- move to previous line, n=2
      INSERT INTO accTable (n, hash, session, "left", isLastPrev, ori)
      SELECT n, MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec,a.hash)),
      a.session, a.left-1, true, a.ori+1
      FROM accTable a, groupTable g, calls c
      WHERE n-1 = a.n
      AND n-1 = g.n
      AND a.hash = g.hash
      AND origin = c.origin
      AND a.session = c.session
      AND a.left-1 = c.line
      AND (n%2=0 OR a.isLastPrev)
      AND NOT (formatPath(initPath) @> c.path
        AND sl = c.sl
        AND sc = c.sc
        AND el = c.el
        AND ec = c.ec);

      -- move to next line, n=2
      INSERT INTO accTable (n, hash, session, "left", isLastPrev, ori)
      SELECT n, MD5(CONCAT(a.hash,formatPath(c.path),c.sl,c.sc,c.el,c.ec)),
      a.session, a.left, false, a.ori
      FROM accTable a, groupTable g, calls c
      WHERE n-1 = a.n
      AND n-1 = g.n
      AND a.hash = g.hash
      AND origin = c.origin
      AND a.session = c.session
      AND a.left+(n-1) = c.line
      AND (n%2=1 OR NOT a.isLastPrev);

    END LOOP;

     RETURN QUERY SELECT g.n, g.hash, a.session, a.left, g.pocc, g.tocc
     FROM   groupTable g
     CROSS  JOIN LATERAL (
      SELECT a.session, a.left
      FROM   accTable a
      WHERE  g.n = a.n AND g.hash = a.hash         -- lateral reference
      LIMIT  1
      ) a;

END;
$BODY$ LANGUAGE plpgsql;
SELECT c.*, g.*
FROM myreq('packages/data/src/components/with-select/index.js',53,71,206,1,5) as g,
     calls c
WHERE 'gutenberg' = c.origin
AND c.session = g.session
AND line >= g.left
AND line < g.left+g.n
ORDER BY g.n, g.hash,g.session,c.line;
#+END_SRC
#+NAME: v3 using some heuristics
#+BEGIN_SRC sql
CREATE OR REPLACE FUNCTION public.formatPath(s char)
 RETURNS ltree AS $BODY$
BEGIN
    return text2ltree(REPLACE(REPLACE(REPLACE(REPLACE(s,'ç','çç'),'-','ç1'),'.','ç0'),'/','.'));
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;
CREATE OR REPLACE FUNCTION public.formatPath(l ltree)
 RETURNS char AS $BODY$
BEGIN
    return REPLACE(REPLACE(REPLACE(REPLACE(ltree2text(l),'.','/'),'ç0','.'),'ç1','-'),'çç','ç');
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;

DROP FUNCTION public.myreq;
CREATE OR REPLACE FUNCTION public.myreq(initPath text, sl int, sc int, el int, ec int,max_n int)
 RETURNS TABLE(n int, hash text, session int, left int, pocc bigint, tocc bigint) AS $BODY$
#variable_conflict use_variable
DECLARE
    chunk int[];
    n int;
    origin char(10);
BEGIN
    origin:='gutenberg';
    n:=1;
    CREATE TEMP TABLE accTable (n int NOT NULL, hash text, session int, "left" int, isLastPrev boolean, ori int, 
                                PRIMARY KEY (n, session, "left", hash)) on commit drop;
    CREATE index ON accTable(n, hash);
    
    INSERT INTO accTable (n, hash, session, "left", isLastPrev, ori)
    SELECT n, MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec)),
           c.session, c.line, false, 0
    FROM CALLS c
    WHERE origin = c.origin
    AND path @> formatPath(initPath)
    AND sl = c.sl
    AND sc = c.sc
    AND el = c.el
    AND ec = c.ec;

    CREATE TEMP TABLE groupTable (n int, hash text, pocc bigint, tocc bigint,
                                  PRIMARY KEY (n, hash)) on commit drop;
    INSERT INTO groupTable (n, hash, pocc, tocc)
    SELECT a.n, a.hash,
           SUM((SIGN(a.session)>0)::int),
           SUM((SIGN(a.session)<0)::int)
    FROM accTable a
    GROUP BY a.n, a.hash;
    
    n:= n + 1;
    -- move to previous line, n=2
    INSERT INTO accTable (n, hash, session, "left", isLastPrev, ori)
    SELECT n, MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec,a.hash)),
    a.session, a."left"-1, true, a.ori+1
    FROM accTable a, (SELECT * FROM groupTable g ORDER BY g.pocc DESC, g.n DESC, g.tocc LIMIT 4*ceil(log(n,n))) g, calls c
    WHERE n-1 = a.n
    AND n-1 = g.n
    AND a.hash = g.hash
    AND a.session = c.session
    AND a.left-1 = c.line
    AND origin = c.origin
    AND NOT (
        formatPath(initPath) @> c.path
        AND sl = c.sl
        AND sc = c.sc
        AND el = c.el
        AND ec = c.ec);
    
    -- move to next line, n=2
    INSERT INTO accTable (n, hash, session, "left", isLastPrev, ori)
    SELECT n, MD5(CONCAT(a.hash,formatPath(c.path),c.sl,c.sc,c.el,c.ec)),
    a.session, a.left, false, a.ori
    FROM accTable a, (SELECT * FROM groupTable g ORDER BY g.pocc DESC, g.n DESC, g.tocc LIMIT 4*ceil(log(n,n))) g, calls c
    WHERE n-1 = a.n
    AND n-1 = g.n
    AND a.hash = g.hash
    AND origin = c.origin
    AND a.session = c.session
    AND a.left+(n-1) = c.line;
    
    LOOP
    
      INSERT INTO groupTable (n, hash, pocc, tocc)
      SELECT a.n, a.hash,
            SUM((SIGN(a.session)>0)::int),
            SUM((SIGN(a.session)<0)::int)
      FROM accTable a
      WHERE n = a.n
      GROUP BY a.n, a.hash;

      EXIT WHEN n >= max_n;

      n:= n + 1;
      ANALYZE accTable;
      -- move to previous line, n=2
      INSERT INTO accTable (n, hash, session, "left", isLastPrev, ori)
      SELECT n, MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec,a.hash)),
      a.session, a.left-1, true, a.ori+1
      FROM accTable a, (SELECT * FROM groupTable g ORDER BY g.pocc DESC, g.n DESC, g.tocc LIMIT 4*ceil(log(n,n))) g, calls c
      WHERE n-1 = a.n
      AND n-1 = g.n
      AND a.hash = g.hash
      AND origin = c.origin
      AND a.session = c.session
      AND a.left-1 = c.line
      AND (n%2=0 OR a.isLastPrev)
      AND NOT (formatPath(initPath) @> c.path
        AND sl = c.sl
        AND sc = c.sc
        AND el = c.el
        AND ec = c.ec);

      -- move to next line, n=2
      INSERT INTO accTable (n, hash, session, "left", isLastPrev, ori)
      SELECT n, MD5(CONCAT(a.hash,formatPath(c.path),c.sl,c.sc,c.el,c.ec)),
      a.session, a.left, false, a.ori
      FROM accTable a, (SELECT * FROM groupTable g ORDER BY g.pocc DESC, g.n DESC, g.tocc LIMIT 4*ceil(log(n,n))) g, calls c
      WHERE n-1 = a.n
      AND n-1 = g.n
      AND a.hash = g.hash
      AND origin = c.origin
      AND a.session = c.session
      AND a.left+(n-1) = c.line
      AND (n%2=1 OR NOT a.isLastPrev);

    END LOOP;

     RETURN QUERY SELECT g.n, g.hash, a.session, a.left, g.pocc, g.tocc
     FROM   groupTable g
     CROSS  JOIN LATERAL (
      SELECT a.session, a.left
      FROM   accTable a
      WHERE  g.n = a.n AND g.hash = a.hash         -- lateral reference
      LIMIT  1
      ) a;

END;
$BODY$ LANGUAGE plpgsql;
SELECT c.*, g.*
FROM myreq('packages/data/src/components/with-select/index.js',53,71,206,1,70) as g,
     calls c
WHERE 'gutenberg' = c.origin
AND c.session = g.session
AND line >= g.left
AND line < g.left+g.n
ORDER BY g.n, g.hash,g.session,c.line;
#+END_SRC
** [2019-06-13 Thu]
*** Plan
**** instrumentation
***** dynamic instrumentation
There is 2 main possibilities to instrument javascript in browser at compile time.
#+BEGIN_EXAMPLE

    --------<script src="xxxxx.js"></script>----<script src="xxxx.com/xxxx.js"></script>------<script>xxxxxxxxxxx</script>------------------------------------------>
             \                            /      \                                    /              \          /
              \                         (*)       \                                  /                +-(6)(*)-+
DOM parsing   (1)                       /         (4)                               /
                \                      /            \                              /
          -------v--------------------^--------------\----------------------------/----
                  \                  /                \                          /
HTTP PACKETS      (2)              (3)                 \                        /
                    \              /                    \                      /
          -----------\------------/----------------------\--------------------/---------------------------
                      \          /                        \                  /
                                                           \----------(5)---/
                                                              \    /
#+END_EXAMPLE
****** Mutation Observer
Using a mutation observer, it allow us to modify scripts added on the page during DOM parsing
This mutation Observer can be directly included in the original page as the first script balise,
on dynamically added to pages with an browser extension
****** Intercepting http requests
Use the Fetch domain of Devtools API (through puppeteer),
to intercept and modify incoming responses to scripts requested.
Make use of the browser cache, js parsing to instrument code is done in the puppeteer (nodejs) process, relieving browser of some stress
Don't work on inline scripts at this point (maybe intercepting html request and parsing the DOM)
***** instrumentation at compile time
**** Venn diag. with symbols of functions
#+BEGIN_EXAMPLE

  +------------------------------------------------------+
  | instrumented                                         |
  | symbols +------------+----------+--------------+     |
  |         |            | prod     |              |     |
  |         |            | & test   |              |     |
  |         |  test      |          |    prod      |     |
  |         |  & -prod   |          |    & -test   |     |
  |         |            |          |              |     |
  |         |            |          |              |     |
  |         +------------+----------+--------------+     |
  |                                                      |
  +------------------------------------------------------+

#+END_EXAMPLE
**** Venn diag. with function's symbols and parameters
#+BEGIN_EXAMPLE

            +------------+----------+--------------+
            |            | prod     |              |
            |            | & test   |              |
            |  test      |          |    prod      |
            |  & -prod   |          |    & -test   |
            |            |          |              |
            |            |          |              |
            +------------+----------+--------------+

#+END_EXAMPLE
**** distribution of calls on dataset
#+BEGIN_SRC
production/test calls sorted by number of occurences of production.
y axis show # of calls
x axis show calls, only some interesting calls are visible.
#+END_SRC
[[file:plots/distrib.png]]
**** DEFERRED distribution of calls with parameters on dataset :noexport:
     CLOSED: [2019-06-20 Thu 16:50] to much points to plot
#+BEGIN_SRC
production/test calls sorted by number of occurences of production.
y axis show # of calls
x axis show calls+parameters, only some interesting calls and parameters are visible.
#+END_SRC
** [2019-06-14 Fri]
*** STARTED read [[http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=877A01775995830BB127116FB11BAB49?doi=10.1.1.323.3411&rep=rep1&type=pdf]]
*** Night idea
recursively compute ngrams and compress previously compared ngrams (parts)
#+BEGIN_SRC sql
CREATE TEMPORARY TABLE aaa(
  n int,
  hash int,
  session int,
  prevl int,
  nextl int
  )
#+END_SRC
#+BEGIN_EXAMPLE
1  2    3      4
x ax_ _11c_ _b111__
            __111b_
      b11__ a222___
            _222c__ -
  _xc _a44_ _b333__ --
            __333b_ -
      __44c __a444_ -
            ___444c
x ax_ _11a_ _b555__
            __555a_
      b11__ _222a__
            c222___
  _xa _a55_ _b666__
            __666a_
      __55a ___777c
            __a777_
x bx_ _22c_ _______
  _xc _b44_ _______
x ax_ _11a_ _______
  _xa _a55_ __222__
x cx_ _33c_ __444__
  _xc _c44_ __444__
x cx_ _33c_ __444__
  _xc _c44_ __444__
x bx_ _22b_ __555__
  _xb _b66_ __555__
#+END_EXAMPLE
** [2019-06-18 Tue]
*** DONE recreate test traces with the new version of gutenberg (5.3)
I implemented an environment that instantiate for each test file an array in the global scope then at the end write it on disk.
*** TODO plot venn diag between prod traces and/or tests
use distribution data?
** [2019-06-19 Wed]
*** DONE plot distribution on subsets of gutenberg
     CLOSED: [2019-06-20 Thu 16:36]
     use =npm run build && node out/makerequests.pg.js | python ../plots/main.py multi-dist line -o ../plots/multidistrib_root2.png= in behaviour-client
*** DONE use https://github.com/Jacarte/bufferedDTW/blob/master/docs/ngram.md
*** STARTED read [[https://cs.uwaterloo.ca/~m2nagapp/courses/CS846/1171/papers/hindle_icse12.pdf][Lossless compaction of model execution traces]]
- xDSML -> models on xDSL
- my traces are only a list of transitions compared to the heterogenous traces targeted by this paper
*** DONE look at [[https://livablesoftware.com/conflictjs-javascript-libraries-conflicts/]]
    CLOSED: [2019-06-20 Thu 11:03]
Out of scope for the internship but the instrumentation tool could be modified to get those king of events (assignments on global scope things)
- One way is to wrap global variables with Proxies
- Could also monitor assignments and filter those accessible from global scope :: I mean do the assignment normally then check is the left hand side can be accessed from a specially made function (that live in the global scope).
*** DONE put links in references
    CLOSED: [2019-06-19 Wed 14:44]
*** DEFERRED try to correct method on the remark of Benoit
    CLOSED: [2019-06-19 Wed 16:04] not possible in my time frame
Benoit Gave me a good remark on my algorithm, telling that it does not compress repetitive patterns.
Like aaaaa should become a+ and abababab should become (ab)+ and more like that.
But taking n=2 like in the first paper makes is only able to compress some patterns.
For now I have some intuitions on the way of doing it.
** [2019-06-20 Thu]
*** TODO read [[http://scholar.google.com/scholar_url?url=https://repositories.lib.utexas.edu/bitstream/handle/2152/74915/DEMIR-THESIS-2018.pdf%3Fsequence%3D1&hl=en&sa=X&d=1403606065224085342&scisig=AAGBfm2v_GD75ccW2YmX0f0YtXa-BA2HfA&nossl=1&oi=scholaralrt&hist=dJQf4SYAAAAJ:5158978984045542397:AAGBfm2WcvuDR2BwMr2WgI3aikY9NcnSzw][Test-splitter: creating unit tests from system tests with different input combinations]]
does not load...
*** TODO plot distribution of interesting packages with more than 1-gram
- multiple standard request?
- async requests on temporary table that is at the same time improved.
*** DONE sql count number of different session where symbol appear
    CLOSED: [2019-06-29 Sat 00:48]
#+BEGIN_SRC sql
array_length(ARRAY_AGG(DISTINCT (CASE WHEN session>0 THEN session ELSE NULL END)),1)
#+END_SRC
*** TODO end query using a timeout
https://stackoverflow.com/questions/9063402/get-execution-time-of-postgresql-query
#+BEGIN_SRC sql
DECLARE
StartTime timestamptz;
  EndTime timestamptz;
  Delta double precision;
BEGIN
  StartTime := clock_timestamp();
  --PERFORM YOUR QUERY HERE;
  EndTime := clock_timestamp();
  Delta := 1000 * ( extract(epoch from EndTime) - extract(epoch from StartTime) );
  RAISE NOTICE 'Duration in millisecs=%', Delta;
#+END_SRC
*** TODO put temporary tables of my pg function in global scope
#+BEGIN_SRC sql
-- contain all processed ngrams
CREATE TABLE accTable (n int NOT NULL, hash text NOT NULL, session int NOT NULL, "left" int NOT NULL, isLastPrev boolean NOT NULL, ori int NOT NULL, 
                       PRIMARY KEY (n, session, "left"));
CREATE index ON accTable(n, hash);
-- if you want to know the number of basic symbols started to be processed, count number of distinct 1,1-gram in accTable
-- if you want to find the row of a particular function search for (1, MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec))) in accTable
-- you can search for missing ngrams looking for gaps in (n, session, left) when sorted
-- if you want to process a new ngram in the database you need to make apply the algorithm starting from the left symbol
-- for any given ngram you can fin how it was contructed looking at the symbol pointed by session,left+ori

-- contain statistics on ngrams, such as occurences in tests and production
CREATE TABLE groupTable (path ltree NOT NULL, sl int NOT NULL, sc int NOT NULL, el int NOT NULL, ec int NOT NULL, n int NOT NULL, hash text NOT NULL, pocc bigint NOT NULL, tocc bigint NOT NULL,
                              PRIMARY KEY (path, sl, sc, el, ec, n, hash));
-- each indexed symbols statitics are accessible through the given symbol then the ngram size
-- so the size of this table should be proportional to the number of indexed symbols and the number of ngram mined through accTable

-- Procedure to instanciate a 1-gram in accTable
-- Caution it shouldn't be used anymore (useless) because entirely computed from calls table and statics in groupTable
INSERT INTO accTable (n, hash, session, "left", isLastPrev, ori)
SELECT n, MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec)),
        c.session, c.line, false, 0
FROM CALLS c
WHERE origin = c.origin
AND path @> formatPath(initPath)
AND sl = c.sl
AND sc = c.sc
AND el = c.el
AND ec = c.ec;

CREATE OR REPLACE FUNCTION public.get2gram(initPath text, sl int, sc int, el int, ec int)
 RETURNS TABLE(n int, hash text, session int, left int, pocc bigint, tocc bigint) AS $BODY$
#variable_conflict use_variable
DECLARE
  n int;
  origin text;
BEGIN
  origin:='gutenberg';
  n:=1;

  WITH a as (
  -- instanciate 1-gram
  SELECT n, MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec)),
          c.session, c.line, false, 0
  FROM CALLS c
  WHERE origin = c.origin
  AND path @> formatPath(initPath)
  AND sl = c.sl
  AND sc = c.sc
  AND el = c.el
  AND ec = c.ec)
  -- Procedure to instanciate statics of 1-gram in groupTable
  INSERT INTO groupTable (path, sl, sc, el, ec, n, hash, pocc, tocc)
  SELECT initPath, sl, sc, el, ec, a.n, a.hash,
          SUM((SIGN(a.session)>0)::int),
          SUM((SIGN(a.session)<0)::int)
  FROM a
  GROUP BY a.n, a.hash;

  n:= n + 1; -- n = 2
  WITH g AS (
    SELECT * FROM groupTable g 
    ORDER BY g.pocc DESC, g.n DESC, g.tocc 
    --LIMIT 4*ceil(log(n,n))
  ), a AS (
  -- move to previous line, n=2
  INSERT INTO accTable (n, hash, session, "left", isLastPrev, ori)
  SELECT n, MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec,a.hash)),
  a.session, a."left"-1, true, a.ori+1
  FROM accTable a,  g, calls c
  WHERE -- n-1 = a.n AND n-1 = g.n AND 
  a.hash = g.hash
  AND a.session = c.session
  AND a.left-1 = c.line
  AND origin = c.origin
  AND NOT (
      formatPath(initPath) @> c.path
      AND sl = c.sl
      AND sc = c.sc
      AND el = c.el
      AND ec = c.ec);
  UNION ALL
  -- move to next line, n=2
  SELECT n, MD5(CONCAT(a.hash,formatPath(c.path),c.sl,c.sc,c.el,c.ec)),
  a.session, a.left, false, a.ori
  FROM accTable a, g, calls c
  WHERE --n-1 = a.n AND n-1 = g.n
  a.hash = g.hash
  AND origin = c.origin
  AND a.session = c.session
  AND a.left+(n-1) = c.line)
  
  INSERT INTO groupTable (n, hash, pocc, tocc)
  SELECT a.n, a.hash,
         SUM((SIGN(a.session)>0)::int),
         SUM((SIGN(a.session)<0)::int)
  FROM a

  RETURN QUERY SELECT g.n, g.hash, a.session, a.left, g.pocc, g.tocc
  FROM   groupTable g
  CROSS  JOIN LATERAL (
  SELECT a.session, a.left
  FROM   accTable a
  WHERE  g.n = a.n AND g.hash = a.hash         -- lateral reference
  LIMIT  1
) a;
END;
$BODY$ LANGUAGE plpgsql;
#+END_SRC
#+NAME: 2gram
#+BEGIN_SRC  sql
CREATE OR REPLACE FUNCTION public.get2gram(initPath text, sl int, sc int, el int, ec int)
 RETURNS TABLE(n int, hash text, session int, left int, pocc bigint, tocc bigint) AS $BODY$
#variable_conflict use_variable
DECLARE
  origin text;
BEGIN
  origin:='gutenberg';

  WITH a1 AS (
    -- get 1-grams of initPath:sl:sc:el:ec
    SELECT MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec)) as hash,
           c.session as session, c.line as "left"
    FROM CALLS c
    WHERE origin = c.origin
    AND path @> formatPath(initPath)
    AND sl = c.sl
    AND sc = c.sc
    AND el = c.el
    AND ec = c.ec
  ), g1 AS (
    -- Procedure to instanciate statics of 1-gram in groupTable
    INSERT INTO groupTable (path, sl, sc, el, ec, n, hash, pocc, tocc)
    SELECT formatPath(initPath), sl, sc, el, ec, 1, a.hash,
           SUM((SIGN(a.session)>0)::int),
           SUM((SIGN(a.session)<0)::int)
    FROM a1 a
    GROUP BY a.hash
    ON CONFLICT ON CONSTRAINT grouptable_pkey 
    DO UPDATE SET pocc = excluded.pocc, tocc = excluded.tocc
    RETURNING hash, pocc, tocc
  ), a2 AS (
  -- move to previous line, n=2
  INSERT INTO accTable (n, hash, session, "left", isLastPrev, ori)
  SELECT 2, MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec,a.hash)),
  a.session, a."left"-1, true, 1
  FROM a1 a, g1 g, calls c
  WHERE a.session = c.session
  AND a.left-1 = c.line
  AND origin = c.origin
  AND NOT (
      formatPath(initPath) @> c.path
      AND sl = c.sl
      AND sc = c.sc
      AND el = c.el
      AND ec = c.ec)
  UNION ALL
  -- move to next line, n=2
  SELECT 2, MD5(CONCAT(a.hash,formatPath(c.path),c.sl,c.sc,c.el,c.ec)),
  a.session, a.left, false, 0
  FROM a1 a, g1 g, calls c
  WHERE origin = c.origin
  AND a.session = c.session
  AND a.left+(2-1) = c.line
    ON CONFLICT ON CONSTRAINT acctable_pkey
    DO UPDATE 
    SET ori = excluded.ori, hash = excluded.hash
    WHERE accTable.ori>excluded.ori
  RETURNING *
  )
  INSERT INTO groupTable (path, sl, sc, el, ec, n, hash, pocc, tocc)
    SELECT formatPath(initPath), sl, sc, el, ec, 2 as n, a.hash,
         SUM((SIGN(a.session)>0)::int),
         SUM((SIGN(a.session)<0)::int)
  FROM a2 a
  GROUP BY n, a.hash
    ON CONFLICT ON CONSTRAINT grouptable_pkey 
    DO UPDATE SET pocc = excluded.pocc, tocc = excluded.tocc;

  RETURN QUERY SELECT g.n, g.hash, a.session, a.left, g.pocc, g.tocc
  FROM   groupTable g
  CROSS  JOIN LATERAL (
    (SELECT c.session as session, c.line as "left"
    FROM CALLS c
    WHERE origin = c.origin
    AND path @> formatPath(initPath)
    AND sl = c.sl
    AND sc = c.sc
    AND el = c.el
    AND ec = c.ec
    AND MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec)) = g.hash         -- lateral reference
    LIMIT 1)
  UNION ALL
  SELECT a.session, a.left
  FROM   accTable a, calls c
  WHERE  g.n = a.n AND g.hash = a.hash         -- lateral reference
  LIMIT  1
) a;
END;
$BODY$ LANGUAGE plpgsql;

SELECT c.*, g.*
FROM get2gram('packages/blocks/src/store/selectors.js'::text,115,29,117,4) as g,
     calls c
WHERE 'gutenberg' = c.origin
AND c.session = g.session
AND line >= g.left
AND line < g.left+g.n
ORDER BY g.n, g.hash,g.session,c.line;
#+END_SRC
#+BEGIN_SRC sql
DROP FUNCTION public.get2gram;
DELETE FROM acctable;DELETE FROM grouptable;
CREATE OR REPLACE FUNCTION public.get2gram(initPath text, sl int, sc int, el int, ec int)
 RETURNS TABLE(n int, hash text, session int, left int, pocc bigint, tocc bigint) AS $BODY$
#variable_conflict use_variable
DECLARE
  origin text;
BEGIN
  origin:='gutenberg';

  WITH a1 AS (
    -- get 1-grams of initPath:sl:sc:el:ec
    SELECT MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec)) as hash,
           c.session as session, c.line as "left"
    FROM CALLS c
    WHERE origin = c.origin
    AND path @> formatPath(initPath)
    AND sl = c.sl
    AND sc = c.sc
    AND el = c.el
    AND ec = c.ec
  ), g1 AS (
    -- Procedure to instanciate statics of 1-gram in groupTable
    INSERT INTO groupTable (path, sl, sc, el, ec, n, hash, pocc, tocc)
    SELECT formatPath(initPath), sl, sc, el, ec, 1, a.hash,
           SUM((SIGN(a.session)>0)::int),
           SUM((SIGN(a.session)<0)::int)
    FROM a1 a
    GROUP BY a.hash
    ON CONFLICT ON CONSTRAINT grouptable_pkey 
    DO UPDATE SET pocc = excluded.pocc, tocc = excluded.tocc
    RETURNING hash, pocc, tocc
  ), a2 AS (
    -- move to previous line, n=2
    INSERT INTO accTable (n, hash, session, "left", isLastPrev, ori)
    SELECT 2, MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec,a.hash)),
    a.session, a."left"-1, true, 1
    FROM a1 a, g1 g, calls c
    WHERE a.session = c.session
    AND a.left-1 = c.line
    AND origin = c.origin
    AND NOT (
        formatPath(initPath) @> c.path
        AND sl = c.sl
        AND sc = c.sc
        AND el = c.el
        AND ec = c.ec)
    UNION ALL
    -- move to next line, n=2
    SELECT 2, MD5(CONCAT(a.hash,formatPath(c.path),c.sl,c.sc,c.el,c.ec)),
    a.session, a.left, false, 0
    FROM a1 a, g1 g, calls c
    WHERE origin = c.origin
    AND a.session = c.session
    AND a.left+(2-1) = c.line
--      ON CONFLICT ON CONSTRAINT acctable_pkey
--      DO UPDATE 
--      SET ori = excluded.ori, hash = excluded.hash
--      WHERE accTable.ori>excluded.ori
      --need to update group table  (change hash)
    RETURNING *
  )
  INSERT INTO groupTable (path, sl, sc, el, ec, n, hash, pocc, tocc)
  SELECT formatPath(initPath), sl, sc, el, ec, 2 as n, a.hash,
         SUM((SIGN(a.session)>0)::int),
         SUM((SIGN(a.session)<0)::int)
  FROM a2 a
  GROUP BY n, a.hash
    ON CONFLICT ON CONSTRAINT grouptable_pkey 
    DO NOTHING; --UPDATE SET pocc = excluded.pocc, tocc = excluded.tocc;

  RETURN QUERY SELECT g.n, g.hash, a.session, a.left, g.pocc, g.tocc
  FROM   groupTable g
  CROSS  JOIN LATERAL (
  SELECT a.session, a.left
  FROM   accTable a, calls c
  WHERE 
    g.path @> formatPath(initPath)
    AND sl = g.sl
    AND sc = g.sc
    AND el = g.el
    AND ec = g.ec
    AND g.n = a.n AND g.hash = a.hash         -- lateral reference
  ORDER BY c.session, c.line
  LIMIT  1
  ) a
  UNION ALL
  SELECT g.n, g.hash, a.session, a.left, g.pocc, g.tocc
  FROM   groupTable g
  CROSS  JOIN LATERAL (
  SELECT c.session as session, c.line as "left"
    FROM CALLS c
    WHERE g.n=1
    AND g.path @> formatPath(initPath)
    AND sl = g.sl    AND sc = g.sc    AND el = g.el    AND ec = g.ec
    AND origin = c.origin
    AND c.path @> formatPath(initPath)
    AND sl = c.sl    AND sc = c.sc    AND el = c.el    AND ec = c.ec
    ORDER BY c.session, c.line
    LIMIT 1) a;
END;
$BODY$ LANGUAGE plpgsql;

SELECT c.*, g.*
FROM get2gram('packages/hooks/src/createRunHook.js',12,0,71,1) as g,
     calls c
WHERE 'gutenberg' = c.origin
AND c.session = g.session
AND line >= g.left
AND line < g.left+g.n
ORDER BY g.n, g.hash,g.session,c.line;

SELECT c.*, g.*
FROM get2gram('packages/hooks/src/createDoingHook.js',10,0,30,1) as g,
     calls c
WHERE 'gutenberg' = c.origin
AND c.session = g.session
AND line >= g.left
AND line < g.left+g.n
ORDER BY g.n, g.hash,g.session,c.line;
#+END_SRC
*** TODO look at https://wiki.postgresql.org/wiki/Don't_Do_This
** [2019-06-25 Tue]
*** DONE multi2gram
#+BEGIN_SRC sql
DROP FUNCTION public.getngrams;
--DELETE FROM acctable;DELETE FROM grouptable;
CREATE OR REPLACE FUNCTION public.compute2gram(initPath text, sl int, sc int, el int, ec int)
 RETURNS void AS $BODY$
#variable_conflict use_variable
DECLARE
  origin text;
BEGIN
  origin:='gutenberg';

  WITH a1 AS (
    -- get 1-grams of initPath:sl:sc:el:ec
    SELECT MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec)) as hash,
           c.session as session, c.line as "left"
    FROM CALLS c
    WHERE origin = c.origin
    AND path @> formatPath(initPath)
    AND sl = c.sl
    AND sc = c.sc
    AND el = c.el
    AND ec = c.ec
  ), g1 AS (
    -- Procedure to instanciate statics of 1-gram in groupTable
    INSERT INTO groupTable (origin, path, sl, sc, el, ec, n, hash, shift, pocc, tocc)
    SELECT origin, formatPath(initPath), sl, sc, el, ec, 1, a.hash, 0,
           SUM((SIGN(a.session)>0)::int),
           SUM((SIGN(a.session)<0)::int)
    FROM a1 a
    GROUP BY a.hash
    ON CONFLICT ON CONSTRAINT grouptable_pkey
    DO UPDATE SET pocc = excluded.pocc, tocc = excluded.tocc
    RETURNING pocc, tocc
  ), a2 AS (
    INSERT INTO accTable (origin, n, hash, session, "left", isLastPrev, shift)
    -- move to previous line, n=2
    SELECT origin, 2, MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec,MD5(CONCAT(formatPath(initPath),sl,sc,el,ec)))) as hash2,
    a.session, a."left"-1, true, 1
    FROM a1 a, g1 g, calls c
    WHERE origin = c.origin
    AND a.session = c.session
    AND a.left-1 = c.line 
    AND NOT (
        formatPath(initPath) <@ c.path
        AND sl = c.sl
        AND sc = c.sc
        AND el = c.el
        AND ec = c.ec)
    UNION ALL
    -- move to next line, n=2
    SELECT origin, 2, MD5(CONCAT(MD5(CONCAT(formatPath(initPath),sl,sc,el,ec)),formatPath(c.path),c.sl,c.sc,c.el,c.ec)) as hash2,
    a.session, a.left, false, 0
    FROM a1 a, g1 g, calls c
    WHERE origin = c.origin
    AND a.session = c.session
    AND a.left+(2-1) = c.line
      ON CONFLICT ON CONSTRAINT acctable_pkey
      DO UPDATE
      SET hash = accTable.hash, shift = LEAST(excluded.shift,accTable.shift)
      --need to update group table  (change hash)
    RETURNING acctable.hash, acctable.session, acctable.shift
  )
  INSERT INTO groupTable (origin, path, sl, sc, el, ec, n, hash, shift, pocc, tocc)
  SELECT origin, formatPath(initPath), sl, sc, el, ec, 2 as n, a.hash, MIN(a.shift),
         SUM((SIGN(a.session)>0)::int),
         SUM((SIGN(a.session)<0)::int)
  FROM a2 a
  WHERE NOT a.hash is NULL
  GROUP BY a.hash
  ON CONFLICT ON CONSTRAINT grouptable_pkey 
  DO UPDATE SET pocc = excluded.pocc, tocc = excluded.tocc;

END;
$BODY$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.getngrams(initPath text, sl int, sc int, el int, ec int, max_n smallint)
 RETURNS TABLE(n int, hash text, session int, left int, pocc bigint, tocc bigint) AS $BODY$
#variable_conflict use_variable
DECLARE
  origin text;
  checkpoint_n smallint;
BEGIN
  origin:='gutenberg';
  checkpoint_n := (
    select MAX(g.n)
    from groupTable g
    where origin = g.origin
    AND g.path @> formatPath(initPath)
    AND sl = g.sl
    AND sc = g.sc
    AND el = g.el
    AND ec = g.ec
    GROUP BY g.path, g.sl, g.sc, g.el, g.ec
  );
  IF checkpoint_n is NULL
  THEN
    PERFORM compute2gram(initPath, sl, sc, el, ec);
  END IF;

  RETURN QUERY SELECT g.n, g.hash, a.session, a.left, g.pocc, g.tocc
  FROM   groupTable g
  CROSS  JOIN LATERAL (
  SELECT a.session, a.left
  FROM   accTable a, calls c
  WHERE 
    g.path @> formatPath(initPath)
    AND sl = g.sl
    AND sc = g.sc
    AND el = g.el
    AND ec = g.ec
    AND g.n = a.n AND g.hash = a.hash         -- lateral reference
  --ORDER BY c.session, c.line
  LIMIT  1
  ) a
  UNION ALL
  SELECT g.n, g.hash, a.session, a.left, g.pocc, g.tocc
  FROM   groupTable g
  CROSS  JOIN LATERAL (
  SELECT c.session as session, c.line as "left"
    FROM CALLS c
    WHERE g.n=1
    AND g.path @> formatPath(initPath)
    AND sl = g.sl    AND sc = g.sc    AND el = g.el    AND ec = g.ec
    AND origin = c.origin
    AND c.path @> formatPath(initPath)
    AND sl = c.sl    AND sc = c.sc    AND el = c.el    AND ec = c.ec
    --ORDER BY c.session, c.line
    LIMIT 1) a;
END;
$BODY$ LANGUAGE plpgsql;

SELECT c.*, g.*
FROM getngrams('packages/hooks/src/createRunHook.js',12,0,71,1,2::smallint) as g,
     calls c
WHERE 'gutenberg' = c.origin
AND c.session = g.session
AND line >= g.left
AND line < g.left+g.n
ORDER BY g.n, g.hash,g.session,c.line;

--EXPLAIN (ANALYZE, BUFFERS) 
SELECT c.*, g.*
FROM getngrams('packages/hooks/src/createDoingHook.js',10,0,30,1,2::smallint) as g,
     calls c
WHERE 'gutenberg' = c.origin
AND c.session = g.session
AND line >= g.left
AND line < g.left+g.n
ORDER BY g.n, g.hash,g.session,c.line;


  SELECT origin, path, sl, sc, el, ec,
  SUM((SIGN(session)>0)::int) as pocc,
  SUM((SIGN(session)<0)::int) as tocc
  FROM calls c
  WHERE origin = 'gutenberg'
  AND path ~ 'packages.blocks.src.*'
  GROUP BY origin, path, sl, sc, el, ec;

WITH initPaths AS (
  SELECT origin, path, sl, sc, el, ec
  FROM calls c
  WHERE origin = 'gutenberg'
  AND path ~ 'packages.blocks.src.api.registrationç0js'
  GROUP BY origin, path, sl, sc, el, ec
)
SELECT g.n, g.hash, g.pocc, g.tocc
FROM initPaths i, LATERAL getngrams(formatPath(i.path),i.sl,i.sc,i.el,i.ec,2::smallint) as g;
#+END_SRC
#+NAME: just forwarding the shift
#+BEGIN_SRC sql
DROP FUNCTION public.getngrams;
--DELETE FROM acctable;DELETE FROM grouptable;
CREATE OR REPLACE FUNCTION public.compute2gram(initPath text, sl int, sc int, el int, ec int)
 RETURNS void AS $BODY$
#variable_conflict use_variable
DECLARE
  origin text;
BEGIN
  origin:='gutenberg';

  WITH a1 AS (
    -- get 1-grams of initPath:sl:sc:el:ec
    SELECT MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec)) as hash,
           c.session as session, c.line as "left"
    FROM CALLS c
    WHERE origin = c.origin
    AND path @> formatPath(initPath)
    AND sl = c.sl
    AND sc = c.sc
    AND el = c.el
    AND ec = c.ec
  ), g1 AS (
    -- Procedure to instanciate statics of 1-gram in groupTable
    INSERT INTO groupTable (origin, path, sl, sc, el, ec, n, hash, shift, pocc, tocc)
    SELECT origin, formatPath(initPath), sl, sc, el, ec, 1, a.hash, 0,
           SUM((SIGN(a.session)>0)::int),
           SUM((SIGN(a.session)<0)::int)
    FROM a1 a
    GROUP BY a.hash
    ON CONFLICT ON CONSTRAINT grouptable_pkey
    DO UPDATE SET pocc = excluded.pocc, tocc = excluded.tocc
    RETURNING pocc, tocc
  ), a2 AS (
    INSERT INTO accTable (origin, n, hash, session, "left", isLastPrev, shift)
    -- move to previous line, n=2
    SELECT origin, 2, MD5(CONCAT(formatPath(c.path),c.sl,c.sc,c.el,c.ec,MD5(CONCAT(formatPath(initPath),sl,sc,el,ec)))) as hash2,
    a.session, a."left"-1, true, 1
    FROM a1 a, g1 g, calls c
    WHERE origin = c.origin
    AND a.session = c.session
    AND a.left-1 = c.line 
    AND NOT (
        formatPath(initPath) <@ c.path
        AND sl = c.sl
        AND sc = c.sc
        AND el = c.el
        AND ec = c.ec)
    UNION ALL
    -- move to next line, n=2
    SELECT origin, 2, MD5(CONCAT(MD5(CONCAT(formatPath(initPath),sl,sc,el,ec)),formatPath(c.path),c.sl,c.sc,c.el,c.ec)) as hash2,
    a.session, a.left, false, 0
    FROM a1 a, g1 g, calls c
    WHERE origin = c.origin
    AND a.session = c.session
    AND a.left+(2-1) = c.line
      ON CONFLICT ON CONSTRAINT acctable_pkey
      DO UPDATE
      SET hash = accTable.hash, shift = excluded.shift --LEAST(excluded.shift,accTable.shift)
      --need to update group table  (change hash)
    RETURNING acctable.hash, acctable.session, acctable.shift
  )
  INSERT INTO groupTable (origin, path, sl, sc, el, ec, n, hash, shift, pocc, tocc)
  SELECT origin, formatPath(initPath), sl, sc, el, ec, 2 as n, a.hash, MIN(a.shift),
         SUM((SIGN(a.session)>0)::int),
         SUM((SIGN(a.session)<0)::int)
  FROM a2 a
  WHERE NOT a.hash is NULL
  GROUP BY a.hash
  ON CONFLICT ON CONSTRAINT grouptable_pkey 
  DO UPDATE SET pocc = excluded.pocc, tocc = excluded.tocc;

END;
$BODY$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.getngrams(initPath text, sl int, sc int, el int, ec int, max_n smallint)
 RETURNS TABLE(n int, hash text, session int, left int, pocc bigint, tocc bigint, shift smallint) AS $BODY$
#variable_conflict use_variable
DECLARE
  origin text;
  checkpoint_n smallint;
BEGIN
  origin:='gutenberg';
  checkpoint_n := (
    select MAX(g.n)
    from groupTable g
    where origin = g.origin
    AND g.path @> formatPath(initPath)
    AND sl = g.sl
    AND sc = g.sc
    AND el = g.el
    AND ec = g.ec
    GROUP BY g.path, g.sl, g.sc, g.el, g.ec
  );
  IF checkpoint_n is NULL
  THEN
    PERFORM compute2gram(initPath, sl, sc, el, ec);
  END IF;

  RETURN QUERY SELECT g.n, g.hash, a.session, a.left, g.pocc, g.tocc, g.shift
  FROM   groupTable g
  CROSS  JOIN LATERAL (
  SELECT a.session, a.left
  FROM   accTable a, calls c
  WHERE 
    g.path @> formatPath(initPath)
    AND sl = g.sl
    AND sc = g.sc
    AND el = g.el
    AND ec = g.ec
    AND g.n = a.n AND g.hash = a.hash         -- lateral reference
  --ORDER BY c.session, c.line
  LIMIT  1
  ) a
  UNION ALL
  SELECT g.n, g.hash, a.session, a.left, g.pocc, g.tocc, g.shift
  FROM   groupTable g
  CROSS  JOIN LATERAL (
  SELECT c.session as session, c.line as "left"
    FROM CALLS c
    WHERE g.n=1
    AND g.path @> formatPath(initPath)
    AND sl = g.sl    AND sc = g.sc    AND el = g.el    AND ec = g.ec
    AND origin = c.origin
    AND c.path @> formatPath(initPath)
    AND sl = c.sl    AND sc = c.sc    AND el = c.el    AND ec = c.ec
    --ORDER BY c.session, c.line
    LIMIT 1) a;
END;
$BODY$ LANGUAGE plpgsql;

SELECT c.*, g.*
FROM getngrams('packages/hooks/src/createRunHook.js',12,0,71,1,2::smallint) as g,
     calls c
WHERE 'gutenberg' = c.origin
AND c.session = g.session
AND line >= g.left
AND line < g.left+g.n
ORDER BY g.n, g.hash,g.session,c.line;

--EXPLAIN (ANALYZE, BUFFERS) 
SELECT c.*, g.*
FROM getngrams('packages/hooks/src/createDoingHook.js',10,0,30,1,2::smallint) as g,
     calls c
WHERE 'gutenberg' = c.origin
AND c.session = g.session
AND line >= g.left
AND line < g.left+g.n
ORDER BY g.n, g.hash,g.session,c.line;


  SELECT origin, path, sl, sc, el, ec,
  SUM((SIGN(session)>0)::int) as pocc,
  SUM((SIGN(session)<0)::int) as tocc
  FROM calls c
  WHERE origin = 'gutenberg'
  AND path ~ 'packages.blocks.src.*'
  GROUP BY origin, path, sl, sc, el, ec;

WITH initPaths AS (
  SELECT origin, path, sl, sc, el, ec
  FROM calls c
  WHERE origin = 'gutenberg'
  AND path ~ 'packages.blocks.src.api.registrationç0js'
  GROUP BY origin, path, sl, sc, el, ec
)
SELECT g.n, g.hash, g.pocc, g.tocc
FROM initPaths i, LATERAL getngrams(formatPath(i.path),i.sl,i.sc,i.el,i.ec,2::smallint) as g;
#+END_SRC
** [2019-06-29 Sat]
*** TODO see http://smlab.cs.tau.ac.il/xlog/lc-ase14.pdf with benoit
* Emacs Settings                                                   :noexport:
Local Variables:
eval:    (setq org-confirm-babel-evaluate nil)
eval:    (org-babel-do-load-languages 'org-babel-load-languages '( (shell . t) (R . t) (perl . t) (ditaa . t) ))
eval:    (setq org-latex-listings 'minted)
eval:    (add-to-list 'org-latex-packages-alist '("" "minted"))
eval:    (setq org-src-fontify-natively t)
eval:    (setq org-image-actual-width '(600))
eval:    (unless (boundp 'org-latex-classes) (setq org-latex-classes nil))
eval:    (add-to-list 'org-latex-classes '("llncs" "\\documentclass{llncs}\n \[NO-DEFAULT-PACKAGES]\n \[EXTRA]\n"  ("\\section{%s}" . "\\section*{%s}") ("\\subsection{%s}" . "\\subsection*{%s}")                       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")                       ("\\paragraph{%s}" . "\\paragraph*{%s}")                       ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
eval:    (setq org-latex-pdf-process (list "latexmk -bibtex -shell-escape -f -pdf %F"))
End:
